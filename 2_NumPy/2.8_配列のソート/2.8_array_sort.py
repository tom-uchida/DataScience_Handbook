# --------------------------
# ----- 2.8 配列のソート -----
# --------------------------
# -----------------------------------------------------
# ----- 2.8.1 NumPyの高速ソート：np.sortとnp.argsort -----
# -----------------------------------------------------
# Pythpnにはリストを扱うsort関数とsorted関数が組み込まれているが，
# NumPyのnp.sort関数の方がはるかに効率的かつ有用．

# もとの配列を変更せずにソートされた配列を得るには，np.sortを使用する．
import numpy as np
x = np.array([2, 1, 4, 3, 5])
np.sort(x)
# array([1, 2, 3, 4, 5])

# 配列自体を変更したければ，配列のsortメソッドを呼び出す．
x.sort()
print(x)
# [1 2 3 4 5]

# argsort関数はソートされた要素のインデクスを返す．
x = np.array([2, 1, 4, 3, 5])
i = np.argsort(x)
print(i)
# [1 0 3 2 4]

# この最初の要素は，最小要素(ここでは1)のインデクスを与え，
# 2番目の値は2番目に小さい要素のインデクスを与える．
# これらのインデクスは，必要に応じてファンシーインデクスによって
# ソートされた配列を作成するために使用できる．
print(x[i])
# [1 2 3 4 5]



# ----------------------------------------
# ----- 2.8.1.1 行または列に沿ったソート -----
# ----------------------------------------
# NumPyのソートアルゴリズムの便利な機能として，
# axis引数を使用して多次元配列の特定の行または列に沿ってソートする機能がある．
rand = np.random.RandomState(42)
X = rand.randint(0, 10, (4, 6))
print(X)
# [[6 3 7 4 6 9]
#  [2 6 7 4 3 7]
#  [7 2 5 4 1 7]
#  [5 1 4 0 9 5]]

# 配列Xの各列をソートする
np.sort(X, axis=0)
# [[2 1 4 0 1 5]
#  [5 2 5 4 3 7]
#  [6 3 7 4 6 7]
#  [7 6 7 4 9 9]]

# 配列Xの各行をソートする
np.sort(X, axis=1)
# [[3 4 6 6 7 9]
#  [2 3 4 6 7 7]
#  [1 2 4 5 7 7]
#  [0 1 4 5 5 9]]





# --------------------------------------------------
# ----- 2.8.2 部分ソート：分割（パーティショニング） -----
# --------------------------------------------------
# 配列全体をソートするのではなく，配列内のK個の最小値を探したいだけという場合がある．
# このためにNumPyの提供するnp.parition関数を使う．
x = np.array([7, 2, 3, 1, 6, 5, 4])
np.partition(x, 3)
# array([2, 1, 3, 4, 6, 5, 7])

# 最初の3つの値は元の配列内の3つの最小値であり，残りの位置には残りの値が含まれている．
# 2つのパーティション内では，要素は任意の順序で並ぶ．





# -----------------------------
# ----- 2.8.3 事例：k近傍法 -----
# -----------------------------
# argsort関数を複数の軸に沿って使い，集合内の各ポイントの最近傍を見つけられるかを見てみる．
# 最初に，10個のランダムな点の集合を作成し，10行2列の配列に格納する．
import matplotlib.pyplot as plt
import seaborn; seaborn.set()

X = rand.rand(10, 2)
print(X)
plt.scatter(X[:, 0], X[:, 1], s=100)
#plt.show()

# 各点の組み合わせに対して，座標ごとの差を計算する
differences = X[:, np.newaxis, :] - X[np.newaxis, :, :]
print(X[:, np.newaxis, :])
X[:, np.newaxis, :].shape # (10, 1, 2)
X[np.newaxis, :, :].shape # (1, 10, 2)
differences.shape         # (10, 10, 2)

# 差を2乗する
sq_differences = differences ** 2
sq_differences.shape # (10, 10, 2)

# 差の2乗を合計して，2乗距離を求める
dist_sq = sq_differences.sum(-1)
dist_sq.shape # (10, 10)

# 確認のために，この行列の対角線（つまり，各点とそれ自身との距離）
# がすべてゼロであることを見てみる．
dist_sq.diagonal()
# array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])


# これで各点ごとの2乗距離が求められたので，
# np.argsortを使って行ごとのソートを行う．
# 最も左の列は，最近傍の点のインデクスとなる．
nearest = np.argsort(dist_sq, axis=1)
print(nearest)
# [[0 3 9 7 1 4 2 5 6 8]
#  [1 4 7 9 3 6 8 5 0 2]
#  [2 1 4 6 3 0 8 9 7 5]
#  [3 9 7 0 1 4 5 8 6 2]
#  [4 1 8 5 6 7 9 3 0 2]
#  [5 8 6 4 1 7 9 3 2 0]
#  [6 8 5 4 1 7 9 3 2 0]
#  [7 9 3 1 4 0 5 8 6 2]
#  [8 5 6 4 1 7 9 3 2 0]
#  [9 7 3 0 1 4 5 8 6 2]]

# ここで全体をソートしたが，実際にはもう少し作業が必要．
# k個の最近傍に興味がある場合，k+1個の最小2乗距離が前方に，
# それらよりも大きな距離が配列の残りの位置を占めるように配列を分割する．
# これをnp.argpartition関数で行う．
K=2
nearest_partition = np.argpartition(dist_sq, K+1, axis=1)

# このネットワークを可視化
plt.scatter(X[:, 0], X[:, 1], s=100)
K=2 # 各点からそれぞれ2つの近傍への線を引く

for i in range(X.shape[0]):
    for j in nearest_partition[i, :K+1]:
        # X[i]からX[j]への線を描くためにzipを使ったトリックを使用する．
        plt.plot(*zip(X[j], X[i]), color='black')
plt.show()


# この方法で使用したブロードキャストと行単位のソートは，
# ループを書くよりも自然ではないかもしれない．
# しかし，Pythonでデータ操作を行うなら，この方法が結局は効率的．