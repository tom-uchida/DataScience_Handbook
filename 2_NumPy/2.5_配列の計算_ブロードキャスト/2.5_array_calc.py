# ---------------------------------------
# ----- 2.5 配列の計算：ブロードキャスト -----
# ---------------------------------------
# ベクトル化操作のもう1つの手段は，NumPyのブロードキャスト機能を使用すること．
# ブロードキャストは，異なるサイズの配列に対して
# 二項ufunc(加算，減算，乗算など)を適用するための一連のルール．



# ------------------------------------
# ----- 2.5.1 ブロードキャストの基礎 -----
# ------------------------------------
# 同じサイズの配列の場合，二項演算は要素ごとに実行される．
import numpy as np
a = np.array([0, 1, 2])
b = np.array([5, 5, 5])
a + b
array([5, 6, 7])

# ブロードキャストでは，この種の二項演算を異なるサイズの配列に対して実行できる．
a + 5
# array([5, 6, 7])
# これは値5をコピーして配列[5, 5, 5]に引き伸ばした上で，
# 配列aとの加算を行う操作と考えられる．
# ※実際にメモリが割り当てられるわけではない．


a = np.arange(3)
b = np.arange(3)[:, np.newaxis]
print(a)
print(b)
# [0 1 2]
# [[0],
#  [1],
#  [2]]
a + b
# array([[0, 1, 2],
#        [1, 2, 3],
#        [2, 3, 4]])
# ここでは，aとbの両方を共通の形に合わせて引き伸ばしたことで，結果は2次元配列となる．





# --------------------------------------
# ----- 2.5.2 ブロードキャストのルール -----
# --------------------------------------
# ルール1
#   2つの配列の次元数が異なる場合，
#   次元数の少ない方の形状は，先頭(左側)に1を補い次元数を揃える．

# ルール2
#   2つの配列の形状がいずれの次元でも一致しない場合，
#   各次元のうち長さが1に等しい次元は，他方の配列形状と一致するように引き伸ばされる．

# ルール3
#   いずれかの次元でサイズが不一致で，長さが1に等しくもない場合は，エラーとなる．



# ------------------------------------
# ----- 2.5.2.1 ブロードキャスト例1 -----
# ------------------------------------
# 1次元配列と2次元配列の加算．
M = np.ones((2, 3)) # M.shape = (2, 3)
a = np.arange(3)    # a.shape = (3,)

# ルール1では，配列aの次元数が少ないので，先頭に1を補う．
M.shape -> (2, 3)   # 2行3列
a.shape -> (1, 3)   # 1行3列
# a = [1, 2, 3]     ← 1次元配列
# a = [[1, 2, 3]]   ← 2次元配列に拡張

# ルール2により，最初の次元が不一致であることから，
# この次元を次のように一致させる．
M.shape -> (2, 3)
a.shape -> (2, 3)



# ------------------------------------
# ----- 2.5.2.2 ブロードキャスト例2 -----
# ------------------------------------
# 双方の配列にブロードキャストが必要となる例．
a = np.arange(3).reshape((3, 1))    # a.shape = (3, 1)
b = np.arange(3)                    # b.shape = (3,)

# ルール1により，bの形状に1を補う必要がある．
a.shape -> (3, 1)
a.shape -> (1, 3)

# ルール2では，他方の配列の対応するサイズと一致するように，
# 長さが1の次元をそれぞれ引き伸ばす．
a.shape -> (3, 3)
b.shape -> (3, 3)



# ------------------------------------
# ----- 2.5.2.3 ブロードキャスト例3 -----
# ------------------------------------
# 2つの配列に互換性がない場合．
M = np.ones((3, 2)) # M.shape = (3, 2)
a = np.arange(3)    # a.shape = (3,)

# ルール1
M.shape -> (3, 2)
a.shape -> (1, 3)

# ルール2
M.shape -> (3, 2)
a.shape -> (3, 3)
# ここでルール3に該当して最終的な形状が一致しないため，
# この2つの配列は互換性がない，





# ------------------------------------
# ----- 2.5.3 ブロードキャストの実践 -----
# ------------------------------------
# -----------------------------------
# ----- 2.5.3.1 配列のセンタリング -----
# -----------------------------------
# 各要素にそれぞれ3つの値をもつ観測値が10個あるとする．
# これを10行3列の配列に保存する．
X = np.random.random((10, 3))

# 集約関数meanを使って1番目の次元に沿って各値の平均を計算する．
Xmean = X.mean(0)

# そして，X配列から平均を引いて，センタリング配列を作る．（ブロードキャスト）
X_centered = X - Xmean



# -----------------------------------
# ----- 2.5.3.2 2次元関数のプロット -----
# -----------------------------------
# ブロードキャストが非常に役立つ場面の1つは，2次元関数のグラフを表示する場合．
# xとyは，0から5の間で，50ステップの値を取る
x = np.linspace(0, 5, 50)
y = np.linspace(0, 5, 50)[:, np.newaxis]

z = np.sin(x)**10 + np.cos(10+y*x)*np.cos(x)
import matplotlib.pyplot as plt
plt.imshow(z, origin='lower', extent=[0, 5, 0, 5], cmap='viridis')
plt.colorbar()
plt.show()