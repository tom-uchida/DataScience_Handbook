# -------------------------------
# ----- 2.2.1 NumPy配列の属性 -----
# -------------------------------
import numpy as np
np.random.seed(0) # 同じ乱数を得るために，乱数シードを設定する

x1 = mp.random.randint(10, size=6)          # 1次元配列
x2 = mp.random.randint(10, size=(3, 4))     # 2次元配列
x3 = mp.random.randint(10, size=(3, 4, 5))  # 3次元配列

# 各配列には，属性として
#   ndim(次元数)
#   shape(各次元のサイズ)
#   size(配列の合計のサイズ)
#   dtype(配列のデータ型)
# をもつ．
print("x3 ndim: ", x3.ndim)     # x3 ndim: 3
print("x3 shape: ", x3.shape)   # x3 shape: (3, 4, 5)
print("x3 size: ", x3.size)     # x3 size: 60
print("x3 dtype: ", x3.dtype)   # x3 dtype: int64





# -------------------------------------------------
# ----- 2.2.3 配列のスライス：部分配列にアクセスする -----
# -------------------------------------------------
# 配列xのスライスにアクセスするには，次の指定方法を使う．
x[start:stop:step]
# デフォルト値は，start=0，stop=その次元のsize，step=1になる．



# ------------------------------------
# ----- 2.2.3.1 1次元配列のスライス -----
# ------------------------------------
x = np.arange(10) 
# → array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

x[:5]   # 最初の5要素
# array([0, 1, 2, 3, 4])

x[5:]   # 最初の5要素
# array([5, 6, 7, 8, 9])

x[4:7]  # 中間の部分配列
# array([4, 5, 6])

x[::2]  # 1つおきの要素
# array([0, 2, 4, 6, 8])

x[1::2] # インデクス1からはじめる1つおきの要素
# array([1, 3, 5, 7, 9])

# 潜在的に混乱するケースは，stepが負の場合．
# この場合，startとstopのデフォルト値が入れ替わる．
# つまり，配列を逆順にする一つの便利な方法となる．
x[::-1]     # 逆順に全ての要素
# array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])

x[5::-2]    # インデクス5から逆順に1つおきの要素
# array([5, 3, 1])



# -------------------------------------
# ----- 2.2.3.2 多次元配列のスライス -----
# -------------------------------------
x2
# → array( [[12, 5, 2, 4],
#           [7, 6, 8, 8],
#           [1, 6, 7, 7]] )

x2[:2, :3]      # 2行と3列
# array( [[12, 5, 2], 
#         [7, 6, 8]] )

x2[:3, ::2]     # 3行と，1つおきの列
# array( [[12, 2], 
#         [7, 8],
#         [1, 7]] )

x2[::-1, ::-1]  # すべての次元を一度に逆にする
# array( [[7, 7, 6, 1], 
#         [8, 8, 6, 7],
#         [4, 2, 5, 12]] )


# 配列のアクセスに関して，最も頻繁に行われる操作は，行または列の抽出．
# これは，インデクスと1つのコロンによる空のスライスとの組み合わせで行う．
print(x2[:, 0]) # x2の最初の列
# [12 7 1]

print(x2[0, :]) # x2の最初の行
# [12 5 2 4]

print(x2[0])    # x2の最初の行(x2[0, :]と等価)
# [12 5 2 4]



# --------------------------------------
# ----- 2.2.3.3 ビューとしての部分配列 -----
# --------------------------------------
# 配列のスライスについて知っておくべき重要かつ非常に有用なことの1つは，
# スライスは配列データの「コピー」ではなく「ビュー」を返すということ．
# Pythonのリストのスライスはコピーを作る．

# 2行2列の部分配列を抽出する
x2_sub = x2[:2, :2]
print(x2_sub)
# [[12 5]
#  [ 7 6]]

# ここでこの部分配列を変更すると，元の配列が変更されたことがわかる．
x2_sub[0, 0] = 99
print(x2_sub)
# [[99 5]
#  [ 7 6]]
print(x2)
# [[99 5 2 4]
#  [ 7 6 8 8]
#  [ 1 6 7 7]]

# このデフォルト動作は，実際には非常に有用．
# つまり，大規模なデータセットを扱う際に，
# 元となるデータバッファをコピーすることなく，そのデータセットにアクセスして処理できる．



# ------------------------------
# ----- 2.2.3.4 配列のコピー -----
# ------------------------------
x2_sub_copy = x2[:2, :2].copy()
print(x2_sub_copy)
# [[99 5]
#  [ 7 6]]

# この部分配列を変更しても，元の配列には影響しない．
x2_sub_copy[0, 0] = 42
print(x2_sub_copy)
# [[42 5]
#  [ 7 6]]
print(x2)
# [[99 5 2 4]
#  [ 7 6 8 8]
#  [ 1 6 7 7]]





# ------------------------------
# ----- 2.2.4 配列の形状変更 -----
# ------------------------------
# 1~9の数字を3行3列に揃える場合には，次のようにする．
grid = np.arrange(1, 10).reshape((3, 3))
print(grid)
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]

# これが機能するためには，
# 変更前の配列の要素数と変更後の配列の要素数が一致しなければならないことに注意．
x = np.array([1, 2, 3])
x.reshape((1, 3))
# array( [[1, 2, 3]] )
x[np.newaxis, :]
# array( [[1, 2, 3]] )
x.reshape((3, 1))
# array( [[1], 
#         [2], 
#         [3]] )
x[:, np.newaxis]
# array( [[1], 
#         [2], 
#         [3]] )





# -------------------------------
# ----- 2.2.5 配列の連結と分割 -----
# -------------------------------
# ----------------------------
# ----- 2.2.5.1 配列の連結 -----
# ----------------------------
# 1次元配列
x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
np.concatenate([x, y])
# array([1, 2, 3, 3, 2, 1])

z = np.array([99, 99, 99])
print(np.concatenate([x, y, z])
# [1 2 3 3 2 1 99 99 99]


# 2次元配列
grid = np.array( [[1, 2, 3],
                  [4, 5, 6]] )
np.concatenate([grid, grid]) # 第1の軸に沿って連結する
# array( [[1, 2, 3], 
#         [4, 5, 6],
#         [1, 2, 3],
#         [4, 5, 6]] )
np.concatenate([grid, grid], axis=1) # 第2の軸に沿って連結する
# array( [[1, 2, 3, 1, 2, 3],
#         [4, 5, 6, 4, 5, 6]] )


# 混合次元の配列を扱う場合，
# np.vstack(垂直スタック)関数と，np.hstack(水平スタック)関数を使用する方がより明確になる．
x = np.array([1, 2, 3])
grid = np.array( [[9, 8, 7],
                  [6, 5, 4]] )
np.vstack([x, grid]) # 配列を垂直に重ねる
# array( [[1, 2, 3], 
#         [9, 8, 7],
#         [6, 5, 4]] )

y = np.array( [[99],
               [99]] )
np.hstack([grid, y]) # 配列を水平に重ねる
# array( [[9, 8, 7, 99],
#         [6, 5, 4, 99]] )

# 同様に，dstackは3番目の軸に沿って配列を積み重ねる．





# ----------------------------
# ----- 2.2.5.2 配列の分割 -----
# ----------------------------
x = [1, 2, 3, 99, 99, 3, 2, 1]
x1, x2, x3 = np.split(x, [3, 5])
print(x1, x2, x3)
# [1 2 3] [99 99] [3 2 1]

# N個の分割点を与えるとN+1個の配列に分割されることに注意．
grid = np.arrange(16).reshape((4, 4))
# array( [[ 0,  1,  2,  3], 
#         [ 4,  5,  6,  7],
#         [ 8,  9, 10, 11],
#         [12, 13, 14, 15]] )

upper, lower = np.vsplit(grid, [2])
print(upper)
print(lower)
# [[0 1 2 3]
#  [4 5 6 7]]
# [[8 9 10 11]
#  [12 13 14 15]]

left, right = np.hsplit(grid, [2])
print(left)
print(right)
# [[ 0 1]
#  [ 4 5]
#  [ 8 9]
#  [12 13]]
# [[ 2 3]
#  [ 6 7]
#  [10 11]
#  [14 15]]

# 同様に，np.dsplitは3番目の軸に沿って配列を分割する．