# -------------------------------------------
# ----- 2.9 構造化データ：NumPyの構造化配列 -----
# -------------------------------------------
# 多くの場合，データは均質な値の配列で十分に表現できるが，そうではない場合もある．
# この節では，NumPyの構造化配列とレコード配列を使用して，
# 複合型の異種データを効率的に格納する方法を示す．

# 多くの人々に対するいくつかのカテゴリのデータ(名前，年齢，体重など)があるとする．
# これらの値をPythonプログラムで使用するために保存したいとする．
import numpy as np

name   = ['Alice', 'Bob', 'Cathy', 'Doug']
age    = [     25,    45,      37,     19]
weight = [   55.0,  85.5,    68.0,   61.5]
# しかし，これは賢い方法ではない．
# 3つの配列がそれぞれ関連していることがわからない．
# 1つの構造体を使用してこれらのデータをすべて格納できるのであれば，その方が自然．

# NumPyでは，複合データ型の配列である構造化配列を使って実現できる．
data = np.zeros(4, dtype={ 'names':('name', 'age', 'weight'),
                           'formats':('U10', 'i4', 'f8') })
print(data.dtype)
# [('name', '<U10'), ('age', '<i4'), ('weight', ,<f8)]
# ここで「U10」は「最大長10のUnicode文字列」を表し，
# 「i4」は「4バイト(=32ビット)整数」を，
# 「f8」は「8バイト(=64ビット)の浮動小数点数」を表す．

# 空の配列を作成したので，値のリストを配列に書き込むことができる．
data['name']   = name
data['age']    = age
data['weight'] = weight
print(data)
# [('Alice', 25, 55.0) ('Bob', 45, 85.5) ('Cathy', 37, 68.0) ('Doug', 19, 61.5)]

# ブール値マスキングと組み合わせれば，年齢による絞り込みなど，
# より洗練された操作も可能となる．
data[data['age'] < 30]['name']
# array(['Alice', 'Doug'],
#       dtype='<U10')


# pandasには，NumPy配列上に構築された構造体であるDataFrameオブジェクトが用意されており，
# ここで示した以上の便利で多彩なデータ操作機能が提供されている．





# -------------------------------
# ----- 2.9.2 より高度な複合型 -----
# -------------------------------
# より高度な複合型を定義できる．
# 例えば，各要素が配列や行列である型を作成できる．
# ここでは，3行3列の浮動少数点行列であるmat要素を加えてデータ型を作成する．
tp = np.dtype([('id', 'i8'), ('mat', 'f8', (3, 3))])
X = np.zeros(1, dtype=tp)
print(X[0])
print(X['mat'][0])
# (0, [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])
# [[0. 0. 0.]
#  [0. 0. 0.]
#  [0. 0. 0.]]





# --------------------------
# ----- 2.9.4 pandasへ -----
# --------------------------
# ここで説明するような構造化配列は，特にNumPy配列を使用して，
# C，Fortran，またはその他言語のバイナリデータフォーマットにアクセスする場合など，
# 特定の状況において必要となる知識です．

# 構造化配列を日常的に使用するならば，pandasの方がはるかに優れた選択肢である．